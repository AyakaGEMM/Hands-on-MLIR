import collections
import logging
import os
import shutil
import sys

sys.path.append(
    os.path.join(
        os.path.dirname(__file__), "../thirdparty/cutlass/python/cutlass_library"
    )
)

from library import (
    CalculateSmemUsage,
    ComplexTransformTag,
    DataTypeSize,
    DataTypeTag,
    EpilogueFunctorTag,
    GemmKind,
    GeneratorTarget,
    LayoutTag,
    LayoutType,
    MathOperationTag,
    OpcodeClass,
    OpcodeClassTag,
    SharedMemPerCC,
    SwizzlingFunctorTag,
    enum,
)
from manifest import OperationKind, OperationKindNames, SubstituteTemplate

_LOGGER = logging.getLogger(__name__)


class EmitOperationKindLibrary:
    def __init__(self, generated_path, min_cc, kind, args):
        self.generated_path = generated_path
        self.min_cc = min_cc
        self.kind = kind
        self.args = args
        self.emitters = {
            OperationKind.Gemm: EmitGemmConfigurationLibrary,
        }

        self.header_template = """
/*
 Generated by hom_manifest.py - Do not edit.
*/

#include "cutlass/cutlass.h"
#include "NVGPUKernels/GemmManifest.h"

namespace mlir {
namespace hands_on_mlir {
namespace homnvgpu_kernel {

///////////////////////////////////////////////////////////////////////////////////////////////////

"""
        self.entry_template = """

//
// Entry point to construct operations
//
void initialize_all_sm${min_cc}_${subclass_name}_${operation_name}_operations(GemmManifest &manifest) {
"""
        self.configuration_prototype_template = (
            "void initialize_${configuration_name}(GemmManifest &manifest);\n"
        )
        self.configuration_template = "  initialize_${configuration_name}(manifest);\n"
        self.subclass_call_template = "  initialize_all_sm${min_cc}_${subclass_name}_${operation_name}_operations(manifest);\n"
        self.subclass_prototype_template = "void initialize_all_sm${min_cc}_${subclass_name}_${operation_name}_operations(GemmManifest &manifest);\n"
        self.epilogue_template = """}

///////////////////////////////////////////////////////////////////////////////////////////////////

} // namespace homnvgpu_kernel
} // namespace library
} // namespace mlir

"""

    #
    def __enter__(self):
        self.operation_path = os.path.join(
            self.generated_path, OperationKindNames[self.kind], str(self.min_cc)
        )
        os.makedirs(self.operation_path)

        self.top_level_path = os.path.join(
            self.operation_path,
            f"all_sm{self.min_cc}_{OperationKindNames[self.kind]}_operations.cu",
        )

        self.top_level_file = open(self.top_level_path, "w")
        self.top_level_file.write(self.header_template)

        self.source_files = {}

        # Each {operation_kind x cc} combination is further decomposed by the instruction
        # types used. This dictionary used to track the file handles for the top-level
        # files of each subclass
        self.subclass_files = {}

        # Configurations in each sub class
        self.subclass_configurations = {}

        return self

    #
    def emit(self, configuration_name, operations):
        assert len(operations) > 0

        # The extended name for all operations of a given configuration_name is guaranteed
        # to be the same because extended_name() is used in defining configuration_name. Thus,
        # we can safely use the extended_name() of the first operation.
        extended_name = operations[0].extended_name()

        # Create a directory for operations with this subclass if it does not exist
        if extended_name not in self.subclass_files:
            subclass_path = os.path.join(self.operation_path, extended_name)
            os.mkdir(subclass_path)

            self.subclass_configurations[extended_name] = []

            # Open a new top-level file for this sub class
            subclass_top_level_path = os.path.join(
                subclass_path,
                f"all_sm{self.min_cc}_{extended_name}_{OperationKindNames[self.kind]}_operations.cu",
            )
            self.subclass_files[extended_name] = open(subclass_top_level_path, "w")
            self.subclass_files[extended_name].write(self.header_template)

            self.source_files[extended_name] = [subclass_top_level_path]

        subclass_dir = os.path.dirname(self.subclass_files[extended_name].name)
        with self.emitters[self.kind](
            subclass_dir, configuration_name
        ) as configuration_emitter:
            for operation in operations:
                configuration_emitter.emit(operation)

            self.source_files[extended_name].append(
                configuration_emitter.configuration_path
            )

        self.subclass_configurations[extended_name].append(configuration_name)
        self.subclass_files[extended_name].write(
            SubstituteTemplate(
                self.configuration_prototype_template,
                {"configuration_name": configuration_name},
            )
        )

    #
    def __exit__(self, exception_type, exception_value, traceback):
        for subclass_name, subclass_file in sorted(self.subclass_files.items()):
            subclass_cfg = {
                "min_cc": str(self.min_cc),
                "subclass_name": subclass_name,
                "operation_name": OperationKindNames[self.kind],
            }
            self.top_level_file.write(
                SubstituteTemplate(self.subclass_prototype_template, subclass_cfg)
            )

        self.top_level_file.write(
            SubstituteTemplate(
                self.entry_template,
                {
                    "min_cc": str(self.min_cc),
                    "subclass_name": "",
                    "operation_name": OperationKindNames[self.kind],
                },
            )
        )

        # Finish and close all subclass files
        for subclass_name, subclass_file in sorted(self.subclass_files.items()):
            subclass_cfg = {
                "min_cc": str(self.min_cc),
                "subclass_name": subclass_name,
                "operation_name": OperationKindNames[self.kind],
            }
            subclass_file.write(SubstituteTemplate(self.entry_template, subclass_cfg))

            for configuration in self.subclass_configurations[subclass_name]:
                subclass_file.write(
                    SubstituteTemplate(
                        self.configuration_template,
                        {"configuration_name": configuration},
                    )
                )

            subclass_file.write(self.epilogue_template)
            subclass_file.close()

            # Write the call to initialize_all for this subclass to the top-level file
            self.top_level_file.write(
                SubstituteTemplate(self.subclass_call_template, subclass_cfg)
            )

        self.top_level_file.write(self.epilogue_template)
        self.top_level_file.close()


class EmitInterfaceLibrary:
    def __init__(self, generated_path, operation_count, args):
        self.generated_path = generated_path
        self.args = args

        self.prototypes = []
        self.fn_calls = []
        self.operation_count = str(operation_count)

        self.top_level_hdr_template = """
/*
 Generated by hom_manifest.py - Do not edit.
*/
"""
        self.top_level_prologue = """

#include "NVGPUKernels/GemmManifest.h"

namespace mlir {
\tnamespace hands_on_mlir {
\t\tnamespace homnvgpu_kernel {

${prototypes}
"""

        self.top_level_initialize_kind = """
\t\tvoid initialize_all_${kind}_operations(GemmManifest &manifest) {
${fn_calls}
\t\t}
"""

        self.top_level_initialize = """
\t\tvoid initialize_all(GemmManifest &manifest) {
\t\t\tmanifest.reserve(${operation_count});\n
${fn_calls}
\t\t}
"""

        self.top_level_suffix = """

\t\t} // namespace homnvgpu_kernel
\t} // namespace hands_on_mlir
} // namespace mlir

"""

    #
    def __enter__(self):
        self.top_level_path = os.path.join(self.generated_path, "initialize_all.cu")

        self.top_level_file = open(self.top_level_path, "w")
        self.top_level_file.write(self.top_level_hdr_template)

        self.source_files = [
            self.top_level_path,
        ]

        return self

    #
    def emit(self, operation_name):
        self.prototypes.append(
            SubstituteTemplate(
                "\t\tvoid initialize_all_${operation_kind}_operations(GemmManifest &manifest);",
                {"operation_kind": operation_name},
            )
        )

        self.fn_calls.append(
            SubstituteTemplate(
                "\t\t\tinitialize_all_${operation_kind}_operations(manifest);",
                {"operation_kind": operation_name},
            )
        )

    #
    def __exit__(self, exception_type, exception_value, traceback):
        self.top_level_file.write(
            SubstituteTemplate(
                self.top_level_prologue, {"prototypes": "\n".join(self.prototypes)}
            )
        )

        # Write out initialize_all method
        self.top_level_file.write(
            SubstituteTemplate(
                self.top_level_initialize,
                {
                    "operation_count": self.operation_count,
                    "fn_calls": "\n".join(self.fn_calls),
                },
            )
        )

        self.top_level_file.write(self.top_level_suffix)
        self.top_level_file.close()


class EmitGemmInstance:
    """Responsible for emitting a CUTLASS template definition"""

    def __init__(self, operation_suffix=""):
        self.operation_suffix = operation_suffix
        self.includes = []
        self.gemm_template = """
  // Gemm operator ${operation_name}
  using Operation_${operation_name} = cutlass::gemm::device::Gemm<
    ${element_a}, ${layout_a},
    ${element_b}, ${layout_b},
    ${element_c}, ${layout_c},
    ${element_accumulator},
    ${opcode_class},
    ${arch},
    cutlass::gemm::GemmShape<${threadblock_shape_m}, ${threadblock_shape_n}, ${threadblock_shape_k}>,
    cutlass::gemm::GemmShape<${warp_shape_m}, ${warp_shape_n}, ${warp_shape_k}>,
    cutlass::gemm::GemmShape<${instruction_shape_m}, ${instruction_shape_n}, ${instruction_shape_k}>,
    ${epilogue_functor}<
      ${element_c},
      ${epilogue_vector_length},
      ${element_accumulator},
      ${element_epilogue}
    >,
    ${swizzling_functor},
    ${stages},
    ${align_a},
    ${align_b},
    false,
    ${math_operation}
    ${residual}
  >;
"""
        self.gemm_complex_template = """
  // Gemm operator ${operation_name}
  using Operation_${operation_name} = cutlass::gemm::device::GemmComplex<
    ${element_a}, ${layout_a},
    ${element_b}, ${layout_b},
    ${element_c}, ${layout_c},
    ${element_accumulator},
    ${opcode_class},
    ${arch},
    cutlass::gemm::GemmShape<${threadblock_shape_m}, ${threadblock_shape_n}, ${threadblock_shape_k}>,
    cutlass::gemm::GemmShape<${warp_shape_m}, ${warp_shape_n}, ${warp_shape_k}>,
    cutlass::gemm::GemmShape<${instruction_shape_m}, ${instruction_shape_n}, ${instruction_shape_k}>,
    ${epilogue_functor}<
      ${element_c},
      ${epilogue_vector_length},
      ${element_accumulator},
      ${element_epilogue}
    >,
    ${swizzling_functor},
    ${stages},
    ${transform_a},
    ${transform_b},
    ${math_operation}
    ${residual}
  >;
"""

    #
    def instance_template(self):
        return """
${compile_guard_start}
  manifest.append(new ${gemm_kind}<Operation_${operation_name}>("${operation_name}"));
${compile_guard_end}
"""

    #
    def emit(self, operation):

        warp_shape = [
            operation.tile_description.threadblock_shape[idx]
            // operation.tile_description.warp_count[idx]
            for idx in range(3)
        ]

        epilogue_vector_length = int(
            min(operation.C.alignment * DataTypeSize[operation.C.element], 128)
            / DataTypeSize[operation.C.element]
        )

        residual = ""

        values = {
            "operation_name": operation.procedural_name(),
            "element_a": DataTypeTag[operation.A.element],
            "layout_a": LayoutTag[operation.A.layout],
            "element_b": DataTypeTag[operation.B.element],
            "layout_b": LayoutTag[operation.B.layout],
            "element_c": DataTypeTag[operation.C.element],
            "layout_c": LayoutTag[operation.C.layout],
            "element_accumulator": DataTypeTag[operation.accumulator_type()],
            "opcode_class": OpcodeClassTag[
                operation.tile_description.math_instruction.opcode_class
            ],
            "arch": "cutlass::arch::Sm%d" % operation.arch,
            "threadblock_shape_m": str(operation.tile_description.threadblock_shape[0]),
            "threadblock_shape_n": str(operation.tile_description.threadblock_shape[1]),
            "threadblock_shape_k": str(operation.tile_description.threadblock_shape[2]),
            "warp_shape_m": str(warp_shape[0]),
            "warp_shape_n": str(warp_shape[1]),
            "warp_shape_k": str(warp_shape[2]),
            "instruction_shape_m": str(
                operation.tile_description.math_instruction.instruction_shape[0]
            ),
            "instruction_shape_n": str(
                operation.tile_description.math_instruction.instruction_shape[1]
            ),
            "instruction_shape_k": str(
                operation.tile_description.math_instruction.instruction_shape[2]
            ),
            "epilogue_vector_length": str(epilogue_vector_length),
            "element_epilogue": str(DataTypeTag[operation.element_epilogue]),
            "epilogue_functor": EpilogueFunctorTag[operation.epilogue_functor],
            "swizzling_functor": SwizzlingFunctorTag[operation.swizzling_functor],
            "stages": str(operation.tile_description.stages),
            "align_a": str(operation.A.alignment),
            "align_b": str(operation.B.alignment),
            "transform_a": ComplexTransformTag[operation.A.complex_transform],
            "transform_b": ComplexTransformTag[operation.B.complex_transform],
            "math_operation": MathOperationTag[
                operation.tile_description.math_instruction.math_operation
            ],
            "residual": residual,
        }

        template = (
            self.gemm_complex_template if operation.is_complex() else self.gemm_template
        )

        return SubstituteTemplate(template, values)


class EmitGemmUniversalInstance:
    """Responsible for emitting a CUTLASS template definition"""

    def __init__(self, operation_suffix=""):
        self.operation_suffix = operation_suffix
        self.includes = [
            "cutlass/cutlass.h",
            "cutlass/numeric_types.h",
            "cutlass/arch/arch.h",
            "cutlass/arch/mma.h",
            "cutlass/layout/matrix.h",
            "cutlass/gemm/device/gemm.h",
            "cutlass/gemm/device/gemm_universal.h",
        ]
        self.builtin_epilogue_functor_template = """
    ${epilogue_functor}<
      ${element_c},
      ${epilogue_vector_length},
      ${element_accumulator},
      ${element_epilogue}
    >
"""
        self.gemm_template = """
// Gemm operator ${operation_name}
using ${operation_name} =
  typename cutlass::gemm::device::GemmUniversal<
    ${element_b}, ${layout_b},    // transposed B operand
    ${element_a}, ${layout_a},    // transposed A operand
    ${element_c}, ${layout_c},
    ${element_accumulator},
    ${opcode_class},
    ${arch},
    cutlass::gemm::GemmShape<${threadblock_shape_m}, ${threadblock_shape_n}, ${threadblock_shape_k}>,
    cutlass::gemm::GemmShape<${warp_shape_m}, ${warp_shape_n}, ${warp_shape_k}>,
    cutlass::gemm::GemmShape<${instruction_shape_m}, ${instruction_shape_n}, ${instruction_shape_k}>,
    ${epilogue_functor},
    ${swizzling_functor},
    ${stages},
    ${align_b},
    ${align_a},
    ${math_operation}
>;
"""

    #
    def instance_template(self):
        return """
${compile_guard_start}
  manifest.append(new ${gemm_kind}<
      ${operation_name}
    >("${operation_name}"));
${compile_guard_end}
"""

    #
    def emit(self, operation):

        threadblock_shape = operation.tile_description.threadblock_shape
        warp_count = operation.tile_description.warp_count

        warp_shape = [threadblock_shape[idx] // warp_count[idx] for idx in range(3)]

        transpose_layouts = {
            LayoutType.ColumnMajor: LayoutType.RowMajor,
            LayoutType.RowMajor: LayoutType.ColumnMajor,
        }

        if (
            operation.A.layout in transpose_layouts.keys()
            and operation.B.layout in transpose_layouts.keys()
            and operation.C.layout in transpose_layouts.keys()
        ):

            instance_layout_A = transpose_layouts[operation.A.layout]
            instance_layout_B = transpose_layouts[operation.B.layout]
            instance_layout_C = transpose_layouts[operation.C.layout]

            gemm_template = self.gemm_template
        else:
            instance_layout_A, instance_layout_B, instance_layout_C = (
                operation.A.layout,
                operation.B.layout,
                operation.C.layout,
            )

            gemm_template = self.gemm_template_interleaved
        #

        # Support built-in epilogue functors or user-defined functions
        if isinstance(operation.epilogue_functor, enum.Enum):

            epilogue_vector_length = (
                min(operation.C.alignment * DataTypeSize[operation.C.element], 128)
                // DataTypeSize[operation.C.element]
            )

            values = {
                "epilogue_vector_length": str(epilogue_vector_length),
                "element_epilogue": str(DataTypeTag[operation.element_epilogue]),
                "epilogue_functor": EpilogueFunctorTag[operation.epilogue_functor],
            }
            epilogue_functor = SubstituteTemplate(
                self.builtin_epilogue_functor_template, values
            )
        else:
            epilogue_functor = self.epilogue_functor.emit_declaration()
        #

        values = {
            "operation_name": operation.procedural_name(),
            "operation_suffix": self.operation_suffix,
            "element_a": DataTypeTag[operation.A.element],
            "layout_a": LayoutTag[instance_layout_A],
            "element_b": DataTypeTag[operation.B.element],
            "layout_b": LayoutTag[instance_layout_B],
            "element_c": DataTypeTag[operation.C.element],
            "layout_c": LayoutTag[instance_layout_C],
            "element_accumulator": DataTypeTag[operation.accumulator_type()],
            "opcode_class": OpcodeClassTag[
                operation.tile_description.math_instruction.opcode_class
            ],
            "arch": "cutlass::arch::Sm%d" % operation.arch,
            "threadblock_shape_m": str(operation.tile_description.threadblock_shape[0]),
            "threadblock_shape_n": str(operation.tile_description.threadblock_shape[1]),
            "threadblock_shape_k": str(operation.tile_description.threadblock_shape[2]),
            "warp_shape_m": str(warp_shape[0]),
            "warp_shape_n": str(warp_shape[1]),
            "warp_shape_k": str(warp_shape[2]),
            "instruction_shape_m": str(
                operation.tile_description.math_instruction.instruction_shape[0]
            ),
            "instruction_shape_n": str(
                operation.tile_description.math_instruction.instruction_shape[1]
            ),
            "instruction_shape_k": str(
                operation.tile_description.math_instruction.instruction_shape[2]
            ),
            "epilogue_functor": epilogue_functor,
            "swizzling_functor": SwizzlingFunctorTag[operation.swizzling_functor],
            "stages": str(operation.tile_description.stages),
            "align_a": str(operation.A.alignment),
            "align_b": str(operation.B.alignment),
            "transform_a": ComplexTransformTag[operation.A.complex_transform],
            "transform_b": ComplexTransformTag[operation.B.complex_transform],
            "math_operation": MathOperationTag[
                operation.tile_description.math_instruction.math_operation
            ],
        }

        return SubstituteTemplate(gemm_template, values)


class EmitGemmConfigurationLibrary:
    def __init__(self, operation_path, configuration_name):
        self.configuration_name = configuration_name
        self.configuration_path = os.path.join(
            operation_path, "%s.cu" % configuration_name
        ).replace("\\", "/")

        self.instance_emitter = {
            GemmKind.Gemm: EmitGemmInstance,
            GemmKind.Universal: EmitGemmUniversalInstance,
        }

        self.gemm_kind_wrappers = {
            GemmKind.Universal: "GemmOperationRunner",
        }

        self.wmma_guard_start = "#if defined(CUTLASS_ARCH_WMMA_SM${sm_number}_ENABLED)"

        self.separator = """
///////////////////////////////////////////////////////////////////////////////////////////////////

"""

        self.header_template = """
/*
  Generated by hom_manifest.py - Do not edit.
*/
"""

        self.initialize_function_template = """

///////////////////////////////////////////////////////////////////////////////////////////////////

namespace mlir {
namespace hands_on_mlir {
namespace homnvgpu_kernel {

///////////////////////////////////////////////////////////////////////////////////////////////////

void initialize_${configuration_name}(GemmManifest &manifest) {

"""
        self.epilogue_template = """

}

///////////////////////////////////////////////////////////////////////////////////////////////////

} // namespace homnvgpu_kernel
} // namespace hands_on_mlir
} // namespace mlir

///////////////////////////////////////////////////////////////////////////////////////////////////

"""

    def __enter__(self):
        self.configuration_file = open(self.configuration_path, "w")
        self.configuration_file.write(self.header_template)
        self.configuration_file.write(self.separator)

        self.includes = collections.OrderedDict(
            [
                ("cutlass/cutlass.h", None),
                ("cutlass/arch/wmma.h", None),
                ("cutlass/numeric_types.h", None),
                ("NVGPUKernels/GemmManifest.h", None),
            ]
        )
        self.instance_definitions = []
        self.instance_wrappers = []

        self.operations = []
        return self

    def emit(self, operation):
        emitter = self.instance_emitter[operation.gemm_kind]()

        for incl in emitter.includes:
            self.includes[incl] = None

        self.operations.append(operation)

        self.instance_definitions.append(emitter.emit(operation))

        self.instance_wrappers.append(
            SubstituteTemplate(
                emitter.instance_template(),
                {
                    "configuration_name": self.configuration_name,
                    "operation_name": operation.procedural_name(),
                    "gemm_kind": self.gemm_kind_wrappers[operation.gemm_kind],
                    "compile_guard_start": (
                        SubstituteTemplate(
                            self.wmma_guard_start, {"sm_number": str(operation.arch)}
                        )
                        if operation.tile_description.math_instruction.opcode_class
                        == OpcodeClass.WmmaTensorOp
                        else ""
                    ),
                    "compile_guard_end": (
                        "#endif"
                        if operation.tile_description.math_instruction.opcode_class
                        == OpcodeClass.WmmaTensorOp
                        else ""
                    ),
                },
            )
        )

    def __exit__(self, exception_type, exception_value, traceback):

        # Write includes
        for incl, _ in self.includes.items():
            include_statement = '#include "%s"\n' % incl
            self.configuration_file.write(include_statement)

        self.configuration_file.write(self.separator)

        # Write instance definitions in top-level namespace
        for instance_definition in self.instance_definitions:
            self.configuration_file.write(instance_definition)

        # Add wrapper objects within initialize() function
        self.configuration_file.write(
            SubstituteTemplate(
                self.initialize_function_template,
                {"configuration_name": self.configuration_name},
            )
        )

        for instance_wrapper in self.instance_wrappers:
            self.configuration_file.write(instance_wrapper)

        self.configuration_file.write(self.epilogue_template)
        self.configuration_file.close()


class EmitOperationKindAll:
    def __init__(self, generated_path, kind, args):
        self.generated_path = generated_path
        self.kind = kind
        self.args = args

        self.header_template = """
/*
 Generated by hom_manifest.py - Do not edit.
*/

#include "cutlass/cutlass.h"
#include "NVGPUKernels/GemmManifest.h"

namespace mlir {
namespace hands_on_mlir {
namespace homnvgpu_kernel {

///////////////////////////////////////////////////////////////////////////////////////////////////

"""

        self.entry_template = """

//
// Entry point to construct operations
//
void initialize_all_${operation_name}_operations(GemmManifest &manifest) {
"""
        self.configuration_prototype_template = (
            "void initialize_${configuration_name}(GemmManifest &manifest);\n"
        )
        self.configuration_template = "  initialize_${configuration_name}(manifest);\n"

        self.epilogue_template = """}

///////////////////////////////////////////////////////////////////////////////////////////////////

} // namespace homnvgpu_kernel
} // namespace hands_on_mlir
} // namespace mlir

"""

    #
    def __enter__(self):
        self.operation_path = os.path.join(
            self.generated_path, OperationKindNames[self.kind]
        )
        os.makedirs(self.operation_path, exist_ok=True)

        self.top_level_path = os.path.join(
            self.operation_path, f"all_{OperationKindNames[self.kind]}_operations.cu"
        )

        self.top_level_file = open(self.top_level_path, "w")
        self.top_level_file.write(self.header_template)

        self.source_files = [
            self.top_level_path,
        ]

        self.configurations = []

        return self

    #
    def emit(self, operations):
        for min_cc, configurations in sorted(operations.items()):
            for configuration_name, _ in configurations.items():
                self.configurations.append(configuration_name)
                self.top_level_file.write(
                    SubstituteTemplate(
                        self.configuration_prototype_template,
                        {"configuration_name": configuration_name},
                    )
                )

    #
    def __exit__(self, exception_type, exception_value, traceback):
        self.top_level_file.write(
            SubstituteTemplate(
                self.entry_template, {"operation_name": OperationKindNames[self.kind]}
            )
        )

        for configuration_name in self.configurations:
            self.top_level_file.write(
                SubstituteTemplate(
                    self.configuration_template,
                    {"configuration_name": configuration_name},
                )
            )

        self.top_level_file.write(self.epilogue_template)
        self.top_level_file.close()


class HOM_Manifest:

    def __init__(self, args=None):
        self.operations = {}
        self.args = args
        self.operation_count = 0
        self.operations_by_name = {}
        self.kernel_filter = ""
        self.kernel_filter_list = []
        self.kernel_names = []
        self.operations_enabled = []
        self.selected_kernels = []
        self.ignore_kernel_names = []
        self.compute_capabilities = [
            50,
        ]
        self.curr_build_dir = "."
        self.filter_by_cc = True
        if self.args:
            self.kernel_filter = self.args.kernels
            self.curr_build_dir = args.curr_build_dir
            architectures = (
                args.architectures.split(";")
                if len(args.architectures)
                else [
                    "50",
                ]
            )
            architectures = [x if x != "90a" else "90" for x in architectures]
            self.compute_capabilities = [int(x) for x in architectures]
            if args.filter_by_cc in ["false", "False", "0"]:
                self.filter_by_cc = False
        if args.operations == "all":
            self.operations_enabled = []
        else:
            operations_list = [
                OperationKind.Gemm,
                OperationKind.Conv2d,
                OperationKind.Conv3d,
                OperationKind.RankK,
                OperationKind.Trmm,
                OperationKind.Symm,
            ]
            self.operations_enabled = [
                x
                for x in operations_list
                if OperationKindNames[x] in args.operations.split(",")
            ]
        if args.kernels == "all":
            self.kernel_names = []
        else:
            self.kernel_names = [x for x in args.kernels.split(",") if x != ""]
        self.ignore_kernel_names = [
            x for x in args.ignore_kernels.split(",") if x != ""
        ]
        if args.kernel_filter_file is None or len(args.kernel_filter_file) == 0:
            self.kernel_filter_list = []
        else:
            self.kernel_filter_list = self.get_kernel_filters(args.kernel_filter_file)
            _LOGGER.debug(
                "Using {filter_count} kernel filters from {filter_file}".format(
                    filter_count=len(self.kernel_filter_list),
                    filter_file=args.kernel_filter_file,
                )
            )
        self.operation_count = 0
        self.operations_by_name = {}
        self.disable_full_archs_compilation = args.disable_full_archs_compilation

    def _filter_string_matches(self, filter_string, haystack):
        """Returns true if all substrings appear in the haystack in order"""
        substrings = filter_string.split("*")
        for sub in substrings:
            idx = haystack.find(sub)
            if idx < 0:
                return False
            haystack = haystack[idx + len(sub) :]
        return True

    def filter(self, operation):
        """Filtering operations based on various criteria"""

        # filter based on compute capability
        enabled = not (self.filter_by_cc)

        for cc in self.compute_capabilities:
            if (
                cc >= operation.tile_description.minimum_compute_capability
                and cc <= operation.tile_description.maximum_compute_capability
                and (
                    cc not in SharedMemPerCC
                    or SharedMemPerCC[cc] >= CalculateSmemUsage(operation)
                )
            ):

                enabled = True
                break

        if not enabled:
            return False

        if (
            len(self.operations_enabled)
            and not operation.operation_kind in self.operations_enabled
        ):
            return False

        # eliminate duplicates
        if operation.procedural_name() in self.operations_by_name.keys():
            return False

        # Filter based on list of valid substrings
        if len(self.kernel_names):
            name = operation.procedural_name()
            enabled = False
            # compare against the include list
            for name_substr in self.kernel_names:
                if self._filter_string_matches(name_substr, name):
                    _LOGGER.debug(
                        "Kernel {kernel} included due to filter string '{filt}'.".format(
                            kernel=operation.procedural_name(), filt=name_substr
                        )
                    )
                    enabled = True
                break
            # compare against the exclude list
            for name_substr in self.ignore_kernel_names:
                if self._filter_string_matches(name_substr, name):
                    _LOGGER.debug(
                        "Kernel {kernel} ignored due to filter string '{filt}'.".format(
                            kernel=operation.procedural_name(), filt=name_substr
                        )
                    )
                    enabled = False
                break

        return enabled

    def append(self, operation):

        if self.filter(operation):
            self.selected_kernels.append(operation.procedural_name())

            self.operations_by_name[operation.procedural_name()] = operation

            # add the configuration
            configuration_name = operation.configuration_name()

            # Split operations by minimum CC
            min_cc = operation.arch

            if operation.operation_kind not in self.operations.keys():
                self.operations[operation.operation_kind] = {}

            if min_cc not in self.operations[operation.operation_kind]:
                self.operations[operation.operation_kind][min_cc] = {}

            if (
                configuration_name
                not in self.operations[operation.operation_kind][min_cc].keys()
            ):
                self.operations[operation.operation_kind][min_cc][
                    configuration_name
                ] = []

            self.operations[operation.operation_kind][min_cc][
                configuration_name
            ].append(operation)
            self.operation_count += 1

    def emit_manifest_cmake(self, manifest_path, top_level_path, source_files):
        with open(manifest_path, "w") as manifest_file:

            libs = []

            for kind in self.operations.keys():
                for min_cc in sorted(self.operations[kind].keys()):
                    for subclass in sorted(source_files[kind][min_cc].keys()):
                        values = {
                            "min_cc": str(min_cc),
                            "kind": OperationKindNames[kind],
                            "subclass": subclass,
                        }
                        lib_name = SubstituteTemplate(
                            """cutlass_${kind}_sm${min_cc}_${subclass}""", values
                        )
                        libs.append(lib_name)
                        target_text = SubstituteTemplate(
                            """add_library(
    cutlass_${kind}_sm${min_cc}_${subclass}
    STATIC
    """,
                            values,
                        )
                        manifest_file.write(target_text + "\n\n")

                        for source_file in source_files[kind][min_cc][subclass]:
                            manifest_file.write(
                                "    %s\n" % str(source_file.replace("\\", "/"))
                            )

                        manifest_file.write(")\n")

                    if self.disable_full_archs_compilation:
                        self.emit_disable_full_archs_compilation(
                            manifest_file, source_files
                        )

            target_text = SubstituteTemplate(
                """add_library(cutlass_library_objs
STATIC
          """,
                {},
            )
            manifest_file.write(target_text + "\n\n")
            manifest_file.write("    %s\n" % str(top_level_path.replace("\\", "/")))
            generated_path = os.path.join(self.curr_build_dir, "generated")
            for kind in self.operations.keys():
                kind_str = OperationKindNames[kind]
                all_kind_file = os.path.join(
                    generated_path, kind_str, f"all_{kind_str}_operations.cu"
                ).replace("\\", "/")
                manifest_file.write(f"    {all_kind_file}\n")
            manifest_file.write(")\n\n")

            manifest_file.write("""target_link_libraries(cutlass_library_objs\n""")
            for lib in libs:
                manifest_file.write(lib + "\n")
            manifest_file.write(")\n")

            manifest_file.write(
                """target_compile_options(cutlass_library_objs PRIVATE -fPIC)\n"""
            )

            for lib in libs:
                manifest_file.write(
                    """target_compile_options(""" + lib + " PRIVATE -fPIC)\n"
                )

    def emit(self, target=GeneratorTarget.Library):

        operation_emitters = {GeneratorTarget.Library: EmitOperationKindLibrary}

        # Emitters for all operations that fall under a particular kind (e.g., GEMM, Conv2d)
        kind_emitters = {GeneratorTarget.Library: EmitOperationKindAll}

        interface_emitters = {GeneratorTarget.Library: EmitInterfaceLibrary}

        generated_path = os.path.join(self.curr_build_dir, "generated")

        # create generated/
        if os.path.exists(generated_path):
            shutil.rmtree(generated_path)

        os.mkdir(generated_path)

        with interface_emitters[target](
            generated_path, self.operation_count, self.args
        ) as iface_emitter:
            top_level_path = iface_emitter.top_level_path
            for operation_kind in self.operations.keys():
                iface_emitter.emit(OperationKindNames[operation_kind])

        source_files = {}
        for kind in self.operations.keys():
            source_files[kind] = {}
            for min_cc in self.operations[kind].keys():
                source_files[kind][min_cc] = {}

        for operation_kind, ops in self.operations.items():
            for min_cc, configurations in sorted(ops.items()):
                with operation_emitters[target](
                    generated_path, min_cc, operation_kind, self.args
                ) as operation_kind_emitter:
                    for configuration_name, operations in configurations.items():
                        operation_kind_emitter.emit(configuration_name, operations)

                    for subclass, files in operation_kind_emitter.source_files.items():
                        if subclass not in source_files[operation_kind][min_cc]:
                            source_files[operation_kind][min_cc][subclass] = []
                            source_files[operation_kind][min_cc][subclass].extend(
                                operation_kind_emitter.source_files[subclass]
                            )

            # Emit top level all_{gemm, conv2d, ...}_operations.cu files
            with kind_emitters[target](
                generated_path, operation_kind, self.args
            ) as operation_kind_emitter:
                operation_kind_emitter.emit(ops)

        # write the manifest.cmake file containing paths from all targets
        manifest_path = os.path.join(generated_path, "manifest.cmake")

        self.emit_manifest_cmake(manifest_path, top_level_path, source_files)
